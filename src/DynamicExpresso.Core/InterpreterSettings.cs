using DynamicExpresso.Parsing;
using DynamicExpresso.Visitors;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;

namespace DynamicExpresso
{
	/// <summary>
	/// Interpreter settings
	/// </summary>
	public class InterpreterSettings
	{
		public ParserSettings ParserSettings { get; }

		public HashSet<ExpressionVisitor> Visitors { get; } = new HashSet<ExpressionVisitor>();

		#region Constructors

		/// <summary>
		/// Creates a new InterpreterSettings using InterpreterOptions.Default.
		/// </summary>
		public InterpreterSettings() : this(InterpreterOptions.Default)
		{
		}

		/// <summary>
		/// Creates a new InterpreterSettings using the specified options.
		/// </summary>
		/// <param name="options"></param>
		public InterpreterSettings(InterpreterOptions options)
		{
			var caseInsensitive = options.HasFlag(InterpreterOptions.CaseInsensitive);

			var lateBindObject = options.HasFlag(InterpreterOptions.LateBindObject);

			ParserSettings = new ParserSettings(caseInsensitive, lateBindObject);

			if ((options & InterpreterOptions.SystemKeywords) == InterpreterOptions.SystemKeywords)
			{
				SetIdentifiers(LanguageConstants.Literals);
			}

			if ((options & InterpreterOptions.PrimitiveTypes) == InterpreterOptions.PrimitiveTypes)
			{
				Reference(LanguageConstants.PrimitiveTypes);
				Reference(LanguageConstants.CSharpPrimitiveTypes);
			}

			if ((options & InterpreterOptions.CommonTypes) == InterpreterOptions.CommonTypes)
			{
				Reference(LanguageConstants.CommonTypes);
			}

			if ((options & InterpreterOptions.LambdaExpressions) == InterpreterOptions.LambdaExpressions)
			{
				ParserSettings.LambdaExpressions = true;
			}

			Visitors.Add(new DisableReflectionVisitor());
		}

		/// <summary>
		/// Create a new interpreter with the settings copied from another interpreter
		/// </summary>
		internal InterpreterSettings(ParserSettings settings)
		{
			ParserSettings = settings;
		}

		#endregion

		#region Properties

		public bool CaseInsensitive
		{
			get
			{
				return ParserSettings.CaseInsensitive;
			}
		}

		/// <summary>
		/// Gets a list of registeres types. Add types by using the Reference method.
		/// </summary>
		public IEnumerable<ReferenceType> ReferencedTypes
		{
			get
			{
				return ParserSettings.KnownTypes
					.Select(p => p.Value)
					.ToList();
			}
		}

		/// <summary>
		/// Gets a list of known identifiers. Add identifiers using SetVariable, SetFunction or SetExpression methods.
		/// </summary>
		public IEnumerable<Identifier> Identifiers
		{
			get
			{
				return ParserSettings.Identifiers
					.Select(p => p.Value)
					.ToList();
			}
		}

		/// <summary>
		/// Gets the available assignment operators.
		/// </summary>
		public AssignmentOperators AssignmentOperators
		{
			get { return ParserSettings.AssignmentOperators; }
		}

		#endregion

		#region Options

		/// <summary>
		/// Allow to set de default numeric type when no suffix is specified (Int by default, Double if real number)
		/// </summary>
		/// <param name="defaultNumberType"></param>
		/// <returns></returns>
		public InterpreterSettings SetDefaultNumberType(DefaultNumberType defaultNumberType)
		{
			ParserSettings.DefaultNumberType = defaultNumberType;
			return this;
		}

		/// <summary>
		/// Allows to enable/disable assignment operators.
		/// For security when expression are generated by the users is more safe to disable assignment operators.
		/// </summary>
		/// <param name="assignmentOperators"></param>
		/// <returns></returns>
		public InterpreterSettings EnableAssignment(AssignmentOperators assignmentOperators)
		{
			ParserSettings.AssignmentOperators = assignmentOperators;
			return this;
		}

		#endregion

		#region Visitors

		/// <summary>
		/// Enable reflection expression (like x.GetType().GetMethod() or typeof(double).Assembly) by removing the DisableReflectionVisitor.
		/// </summary>
		/// <returns></returns>
		public InterpreterSettings EnableReflection()
		{
			var visitor = Visitors.FirstOrDefault(p => p is DisableReflectionVisitor);
			if (visitor != null)
				Visitors.Remove(visitor);

			return this;
		}

		#endregion

		#region Register identifiers

		/// <summary>
		/// Allow the specified function delegate to be called from a parsed expression.
		/// </summary>
		/// <param name="name"></param>
		/// <param name="value"></param>
		/// <returns></returns>
		public InterpreterSettings SetFunction(string name, Delegate value)
		{
			if (string.IsNullOrWhiteSpace(name))
				throw new ArgumentNullException(nameof(name));

			if (ParserSettings.Identifiers.TryGetValue(name, out var identifier) && identifier is FunctionIdentifier fIdentifier)
			{
				fIdentifier.AddOverload(value);
			}
			else
			{
				SetIdentifier(new FunctionIdentifier(name, value));
			}

			return this;
		}

		/// <summary>
		/// Allow the specified variable to be used in a parsed expression.
		/// </summary>
		/// <param name="name"></param>
		/// <param name="value"></param>
		/// <returns></returns>
		public InterpreterSettings SetVariable(string name, object value)
		{
			if (string.IsNullOrWhiteSpace(name))
				throw new ArgumentNullException(nameof(name));

			return SetExpression(name, Expression.Constant(value));
		}

		/// <summary>
		/// Allow the specified variable to be used in a parsed expression.
		/// </summary>
		/// <param name="name"></param>
		/// <param name="value"></param>
		/// <returns></returns>
		public InterpreterSettings SetVariable<T>(string name, T value)
		{
			return SetVariable(name, value, typeof(T));
		}

		/// <summary>
		/// Allow the specified variable to be used in a parsed expression.
		/// </summary>
		/// <param name="name"></param>
		/// <param name="value"></param>
		/// <param name="type"></param>
		/// <returns></returns>
		public InterpreterSettings SetVariable(string name, object value, Type type)
		{
			if (type == null)
				throw new ArgumentNullException(nameof(type));

			if (string.IsNullOrWhiteSpace(name))
				throw new ArgumentNullException(nameof(name));

			return SetExpression(name, Expression.Constant(value, type));
		}

		/// <summary>
		/// Allow the specified Expression to be used in a parsed expression.
		/// Basically add the specified expression as a known identifier.
		/// </summary>
		/// <param name="name"></param>
		/// <param name="expression"></param>
		/// <returns></returns>
		public InterpreterSettings SetExpression(string name, Expression expression)
		{
			return SetIdentifier(new Identifier(name, expression));
		}

		/// <summary>
		/// Allow the specified list of identifiers to be used in a parsed expression.
		/// Basically add the specified expressions as a known identifier.
		/// </summary>
		/// <param name="identifiers"></param>
		/// <returns></returns>
		public InterpreterSettings SetIdentifiers(IEnumerable<Identifier> identifiers)
		{
			foreach (var i in identifiers)
				SetIdentifier(i);

			return this;
		}

		/// <summary>
		/// Allow the specified identifier to be used in a parsed expression.
		/// Basically add the specified expression as a known identifier.
		/// </summary>
		/// <param name="identifier"></param>
		/// <returns></returns>
		public InterpreterSettings SetIdentifier(Identifier identifier)
		{
			if (identifier == null)
				throw new ArgumentNullException(nameof(identifier));

			if (LanguageConstants.ReservedKeywords.Contains(identifier.Name))
				throw new InvalidOperationException($"{identifier.Name} is a reserved word");

			ParserSettings.Identifiers[identifier.Name] = identifier;
			return this;
		}
		#endregion

		#region Register referenced types
		/// <summary>
		/// Allow the specified type to be used inside an expression. The type will be available using its name.
		/// If the type contains method extensions methods they will be available inside expressions.
		/// </summary>
		/// <param name="type"></param>
		/// <returns></returns>
		public InterpreterSettings Reference(Type type)
		{
			if (type == null)
				throw new ArgumentNullException(nameof(type));

			return Reference(type, type.Name);
		}

		/// <summary>
		/// Allow the specified type to be used inside an expression.
		/// See Reference(Type, string) method.
		/// </summary>
		/// <param name="types"></param>
		/// <returns></returns>
		public InterpreterSettings Reference(IEnumerable<ReferenceType> types)
		{
			if (types == null)
				throw new ArgumentNullException(nameof(types));

			foreach (var t in types)
				Reference(t);

			return this;
		}

		/// <summary>
		/// Allow the specified type to be used inside an expression by using a custom alias.
		/// If the type contains extensions methods they will be available inside expressions.
		/// </summary>
		/// <param name="type"></param>
		/// <param name="typeName">Public name that must be used in the expression.</param>
		/// <returns></returns>
		public InterpreterSettings Reference(Type type, string typeName)
		{
			return Reference(new ReferenceType(typeName, type));
		}

		/// <summary>
		/// Allow the specified type to be used inside an expression by using a custom alias.
		/// If the type contains extensions methods they will be available inside expressions.
		/// </summary>
		/// <param name="type"></param>
		/// <returns></returns>
		public InterpreterSettings Reference(ReferenceType type)
		{
			if (type == null)
				throw new ArgumentNullException(nameof(type));

			ParserSettings.KnownTypes[type.Name] = type;

			foreach (var extensionMethod in type.ExtensionMethods)
			{
				ParserSettings.ExtensionMethods.Add(extensionMethod);
			}

			return this;
		}

		#endregion
	}
}
